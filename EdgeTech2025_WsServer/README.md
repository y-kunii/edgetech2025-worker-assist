# è£½é€ ç¾å ´ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ„ã‚¤ãƒ³ãƒ‡ãƒ¢

è£½é€ ç¾å ´ã«ãŠã‘ã‚‹äººã¨ãƒ­ãƒœãƒƒãƒˆã®å”èª¿å‹•ä½œã‚’å¯è¦–åŒ–ã™ã‚‹Electronãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚

## æ©Ÿèƒ½æ¦‚è¦

### ä¸»è¦æ©Ÿèƒ½
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–**: ä½œæ¥­è€…ãƒ»ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º
- **é€²æ—å¯è¦–åŒ–**: ãƒã‚¸ç· ã‚ãƒ»ãƒœãƒ«ãƒˆç· ã‚ã®é€²æ—ã‚’å††ã‚°ãƒ©ãƒ•ã§è¡¨ç¤º
- **å±¥æ­´ç®¡ç†**: ä½œæ¥­å±¥æ­´ã‚’ã‚¿ã‚¤ãƒ ãƒãƒ£ãƒ¼ãƒˆã§å¯è¦–åŒ–
- **WebSocketé€šä¿¡**: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿å—ä¿¡ãƒ»é€ä¿¡
- **ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡**: ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã¸ã®æŒ‡ç¤ºé€ä¿¡ã¨å¿œç­”ç›£è¦–
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**: ãƒ‡ãƒã‚¤ã‚¹æ€§èƒ½ã«å¿œã˜ãŸå‹•çš„æœ€é©åŒ–
- **ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³**: æ§˜ã€…ãªç”»é¢ã‚µã‚¤ã‚ºã«å¯¾å¿œ

### æœ€é©åŒ–æ©Ÿèƒ½
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–**: ãƒ¡ãƒ¢ãƒªã€CPUã€ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
- **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æœ€é©åŒ–**: ãƒ‡ãƒã‚¤ã‚¹æ€§èƒ½ã«å¿œã˜ãŸã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³èª¿æ•´
- **ãƒ‡ãƒ¼ã‚¿çµ±åˆç®¡ç†**: ãƒãƒƒãƒå‡¦ç†ã«ã‚ˆã‚‹åŠ¹ç‡çš„ãªãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼
- **ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–**: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ã¨è‡ªå‹•ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

- **Electron**: ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œ
- **React + TypeScript**: UIé–‹ç™º
- **Chart.js**: ã‚°ãƒ©ãƒ•è¡¨ç¤º
- **Socket.io**: WebSocketé€šä¿¡
- **Webpack**: ãƒãƒ³ãƒ‰ãƒ«
- **Jest**: ãƒ†ã‚¹ãƒˆ

## ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

### 1. ä¾å­˜é–¢ä¿‚ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
npm install
```

### 2. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ“ãƒ«ãƒ‰

```bash
npm run build:dev
```

### 3. ãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ï¼ˆåˆ¥ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ï¼‰

```bash
npm run mock-server
```

### 4. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•

```bash
npm start
```

ã¾ãŸã¯é–‹ç™ºãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ä»˜ãï¼‰:

```bash
npm run dev
```

### 5. å‹•ä½œç¢ºèª

1. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒèµ·å‹•ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã« `ws://localhost:3001` ã«æ¥ç¶šã—ã¾ã™
2. æ¥ç¶šçŠ¶æ…‹ã¯ç”»é¢å³ä¸Šã®ã€ŒğŸŸ¢ æ¥ç¶šè‰¯å¥½ã€ã§ç¢ºèªã§ãã¾ã™
3. ãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰2ç§’é–“éš”ã§ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒé€ä¿¡ã•ã‚Œã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§ç”»é¢ãŒæ›´æ–°ã•ã‚Œã¾ã™
4. ã€ŒğŸ¤– ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡ã€ãƒœã‚¿ãƒ³ã‹ã‚‰ãƒ­ãƒœãƒƒãƒˆã¸ã®æŒ‡ç¤ºé€ä¿¡ã‚’ãƒ†ã‚¹ãƒˆã§ãã¾ã™

## é–‹ç™ºã‚³ãƒãƒ³ãƒ‰

- `npm run build` - ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ãƒ“ãƒ«ãƒ‰
- `npm run build:dev` - é–‹ç™ºãƒ“ãƒ«ãƒ‰
- `npm run dev` - é–‹ç™ºãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ›ãƒƒãƒˆãƒªãƒ­ãƒ¼ãƒ‰ï¼‰
- `npm run test` - ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
- `npm run lint` - ESLintãƒã‚§ãƒƒã‚¯
- `npm run format` - Prettierãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
- `npm run mock-server` - ãƒ¢ãƒƒã‚¯WebSocketã‚µãƒ¼ãƒãƒ¼èµ·å‹•

## ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
src/
â”œâ”€â”€ main/           # Electronãƒ¡ã‚¤ãƒ³ãƒ—ãƒ­ã‚»ã‚¹
â”œâ”€â”€ renderer/       # Reactãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹
â”œâ”€â”€ mock-server/    # ãƒ¢ãƒƒã‚¯WebSocketã‚µãƒ¼ãƒãƒ¼
â””â”€â”€ types/          # TypeScriptå‹å®šç¾©
```

## WebSocketé€šä¿¡ã¨ãƒ‡ãƒ¼ã‚¿é€£æº

### æ¥ç¶šè¨­å®š

ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯èµ·å‹•æ™‚ã«è‡ªå‹•çš„ã«WebSocketã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã¾ã™ã€‚

**ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š:**
- URL: `ws://localhost:3001`
- å†æ¥ç¶šè©¦è¡Œå›æ•°: 10å›
- å†æ¥ç¶šé–“éš”: 1ç§’
- ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: 5ç§’

**ç’°å¢ƒå¤‰æ•°ã«ã‚ˆã‚‹è¨­å®šå¤‰æ›´:**
```bash
# WebSocketã‚µãƒ¼ãƒãƒ¼ã®URLå¤‰æ›´
export WEBSOCKET_URL=ws://your-server:port

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•
npm start
```

### ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼

```mermaid
graph LR
    A[ã‚»ãƒ³ã‚µãƒ¼/ã‚«ãƒ¡ãƒ©] --> B[WebSocketã‚µãƒ¼ãƒãƒ¼]
    B --> C[Electronã‚¢ãƒ—ãƒª]
    C --> D[UIæ›´æ–°]
    C --> E[ãƒ­ãƒœãƒƒãƒˆæŒ‡ç¤º]
    E --> B
    B --> F[ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ]
```

### å—ä¿¡ãƒ‡ãƒ¼ã‚¿å½¢å¼

#### ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ (`sensor_data`)

```json
{
  "image": "data:image/jpeg;base64,/9j/4AAQ...", // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸç”»åƒï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
  "worker_status": "screw_tightening",           // ä½œæ¥­è€…çŠ¶æ…‹
  "robot_status": {
    "state": "operating",                        // ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹
    "grip": "open"                              // ã‚°ãƒªãƒƒãƒ—çŠ¶æ…‹
  },
  "screw_count": 3,                             // ãƒã‚¸ç· ã‚å›æ•°
  "bolt_count": 1,                              // ãƒœãƒ«ãƒˆç· ã‚å›æ•°
  "work_step": "screw_tightening"               // ç¾åœ¨ã®ä½œæ¥­ã‚¹ãƒ†ãƒƒãƒ—
}
```

**ä½œæ¥­è€…çŠ¶æ…‹ (`worker_status`)**
- `waiting`: å¾…æ©Ÿä¸­
- `screw_tightening`: ãƒã‚¸ç· ã‚ä½œæ¥­ä¸­
- `bolt_tightening`: ãƒœãƒ«ãƒˆç· ã‚ä½œæ¥­ä¸­
- `tool_handover`: å·¥å…·å—ã‘æ¸¡ã—ä¸­
- `absent`: ä¸åœ¨

**ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹ (`robot_status.state`)**
- `waiting`: å¾…æ©Ÿä¸­
- `operating`: å‹•ä½œä¸­

**ã‚°ãƒªãƒƒãƒ—çŠ¶æ…‹ (`robot_status.grip`)**
- `open`: é–‹ã„ã¦ã„ã‚‹
- `closed`: é–‰ã˜ã¦ã„ã‚‹

### é€ä¿¡ãƒ‡ãƒ¼ã‚¿å½¢å¼

#### ãƒ­ãƒœãƒƒãƒˆæŒ‡ç¤º (`robot_command`)

```json
{
  "command": "tool_handover",                   // æŒ‡ç¤ºã‚³ãƒãƒ³ãƒ‰
  "data": {                                     // è¿½åŠ ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    "tool_type": "screwdriver",
    "position": { "x": 100, "y": 200, "z": 50 }
  },
  "timestamp": "2024-01-01T12:00:00.000Z"     // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
}
```

**æŒ‡ç¤ºã‚³ãƒãƒ³ãƒ‰ç¨®é¡**
- `tool_handover`: å·¥å…·å—ã‘æ¸¡ã—
- `next_task`: æ¬¡ã‚¿ã‚¹ã‚¯ã¸ç§»è¡Œ
- `emergency_stop`: ç·Šæ€¥åœæ­¢
- `reset`: ãƒªã‚»ãƒƒãƒˆ

### æ¥ç¶šçŠ¶æ…‹ç®¡ç†

ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯æ¥ç¶šçŠ¶æ…‹ã‚’è‡ªå‹•ç›£è¦–ã—ã€ä»¥ä¸‹ã®æƒ…å ±ã‚’æä¾›ã—ã¾ã™ï¼š

- **æ¥ç¶šçŠ¶æ…‹**: æ¥ç¶šä¸­/åˆ‡æ–­ä¸­
- **æ¥ç¶šå“è³ª**: ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ã¨ãƒ‡ãƒ¼ã‚¿ãƒ¬ãƒ¼ãƒˆã«åŸºã¥ãå“è³ªè©•ä¾¡
- **è‡ªå‹•å†æ¥ç¶š**: åˆ‡æ–­æ™‚ã®è‡ªå‹•å†æ¥ç¶šæ©Ÿèƒ½
- **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: é€šä¿¡ã‚¨ãƒ©ãƒ¼ã®é©åˆ‡ãªå‡¦ç†

## ãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼

é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆç”¨ã®WebSocketã‚µãƒ¼ãƒãƒ¼ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚

### èµ·å‹•æ–¹æ³•

```bash
npm run mock-server
```

### æä¾›æ©Ÿèƒ½

- **HTTP ã‚µãƒ¼ãƒãƒ¼**: `http://localhost:3001`
  - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯: `GET /health`
  - CORSå¯¾å¿œ
- **WebSocket ã‚µãƒ¼ãƒãƒ¼**: `ws://localhost:3001`
  - è‡ªå‹•ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿é€ä¿¡ï¼ˆ2ç§’é–“éš”ï¼‰
  - ãƒ­ãƒœãƒƒãƒˆã‚³ãƒãƒ³ãƒ‰å—ä¿¡ãƒ»å¿œç­”
  - æ¥ç¶šçŠ¶æ…‹ç®¡ç†

### ãƒ¢ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ

ãƒ¢ãƒƒã‚¯ã‚µãƒ¼ãƒãƒ¼ã¯ä»¥ä¸‹ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã—ã¾ã™ï¼š

- **ä½œæ¥­è€…çŠ¶æ…‹**: ãƒ©ãƒ³ãƒ€ãƒ ãªçŠ¶æ…‹é·ç§»
- **ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹**: ä½œæ¥­è€…çŠ¶æ…‹ã«é€£å‹•ã—ãŸå‹•ä½œ
- **ã‚«ã‚¦ãƒ³ãƒˆå€¤**: æ®µéšçš„ãªå¢—åŠ 
- **ç”»åƒãƒ‡ãƒ¼ã‚¿**: Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸã‚µãƒ³ãƒ—ãƒ«ç”»åƒï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

## å®Ÿéš›ã®WebSocketã‚µãƒ¼ãƒãƒ¼å®Ÿè£…ã‚¬ã‚¤ãƒ‰

### ã‚µãƒ¼ãƒãƒ¼å´è¦ä»¶

å®Ÿéš›ã®è£½é€ ç¾å ´ã§ä½¿ç”¨ã™ã‚‹å ´åˆã€ä»¥ä¸‹ã®ä»•æ§˜ã«å¯¾å¿œã—ãŸWebSocketã‚µãƒ¼ãƒãƒ¼ãŒå¿…è¦ã§ã™ã€‚

#### 1. åŸºæœ¬æ¥ç¶š

```javascript
// Node.js + Socket.io ã®ä¾‹
const io = require('socket.io')(3001, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"]
  }
});

io.on('connection', (socket) => {
  console.log('Client connected:', socket.id);
  
  // å®šæœŸçš„ãªã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿é€ä¿¡
  const interval = setInterval(() => {
    socket.emit('sensor_data', {
      worker_status: getCurrentWorkerStatus(),
      robot_status: getCurrentRobotStatus(),
      screw_count: getScrewCount(),
      bolt_count: getBoltCount(),
      work_step: getCurrentWorkStep(),
      image: getCameraImage() // ã‚ªãƒ—ã‚·ãƒ§ãƒ³
    });
  }, 1000); // 1ç§’é–“éš”
  
  // ãƒ­ãƒœãƒƒãƒˆæŒ‡ç¤ºå—ä¿¡
  socket.on('robot_command', (data) => {
    console.log('Robot command received:', data);
    
    // ãƒ­ãƒœãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ ã«æŒ‡ç¤ºã‚’è»¢é€
    sendCommandToRobot(data.command, data.data);
    
    // å¿œç­”é€ä¿¡
    socket.emit('robot_response', {
      command: data.command,
      status: 'success',
      timestamp: new Date().toISOString()
    });
  });
  
  socket.on('disconnect', () => {
    clearInterval(interval);
    console.log('Client disconnected:', socket.id);
  });
});
```

#### 2. ã‚»ãƒ³ã‚µãƒ¼çµ±åˆ

```python
# Python ã®ä¾‹ï¼ˆã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿åé›†ï¼‰
import cv2
import json
import base64
from socketio import Server

class SensorManager:
    def __init__(self):
        self.camera = cv2.VideoCapture(0)
        self.worker_detector = WorkerDetector()
        self.robot_interface = RobotInterface()
    
    def get_sensor_data(self):
        # ã‚«ãƒ¡ãƒ©ç”»åƒå–å¾—
        ret, frame = self.camera.read()
        image_base64 = None
        if ret:
            _, buffer = cv2.imencode('.jpg', frame)
            image_base64 = base64.b64encode(buffer).decode('utf-8')
            image_base64 = f"data:image/jpeg;base64,{image_base64}"
        
        # ä½œæ¥­è€…çŠ¶æ…‹æ¤œå‡º
        worker_status = self.worker_detector.detect_status(frame)
        
        # ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹å–å¾—
        robot_status = self.robot_interface.get_status()
        
        return {
            'image': image_base64,
            'worker_status': worker_status,
            'robot_status': robot_status,
            'screw_count': self.get_screw_count(),
            'bolt_count': self.get_bolt_count(),
            'work_step': worker_status
        }
```

#### 3. ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡çµ±åˆ

```cpp
// C++ ã®ä¾‹ï¼ˆãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡ï¼‰
#include <websocketpp/config/asio_no_tls.hpp>
#include <websocketpp/server.hpp>

class RobotController {
public:
    void handleCommand(const std::string& command, const json& data) {
        if (command == "tool_handover") {
            executeToolHandover(data);
        } else if (command == "next_task") {
            moveToNextTask(data);
        } else if (command == "emergency_stop") {
            emergencyStop();
        }
    }
    
private:
    void executeToolHandover(const json& data) {
        // ãƒ­ãƒœãƒƒãƒˆã‚¢ãƒ¼ãƒ ã‚’å·¥å…·å—ã‘æ¸¡ã—ä½ç½®ã«ç§»å‹•
        moveToPosition(data["position"]);
        openGripper();
        // å®Œäº†é€šçŸ¥
        notifyCompletion("tool_handover", "success");
    }
};
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è€ƒæ…®äº‹é …

#### 1. èªè¨¼ãƒ»èªå¯

```javascript
// JWTèªè¨¼ã®ä¾‹
const jwt = require('jsonwebtoken');

io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    socket.userId = decoded.userId;
    next();
  } catch (err) {
    next(new Error('Authentication error'));
  }
});
```

#### 2. ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–

```javascript
// TLS/SSLå¯¾å¿œ
const fs = require('fs');
const https = require('https');

const server = https.createServer({
  key: fs.readFileSync('path/to/private-key.pem'),
  cert: fs.readFileSync('path/to/certificate.pem')
});

const io = require('socket.io')(server);
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### 1. ãƒ‡ãƒ¼ã‚¿åœ§ç¸®

```javascript
// ç”»åƒãƒ‡ãƒ¼ã‚¿ã®åœ§ç¸®
const sharp = require('sharp');

async function compressImage(imageBuffer) {
  return await sharp(imageBuffer)
    .resize(640, 480)
    .jpeg({ quality: 80 })
    .toBuffer();
}
```

#### 2. è² è·åˆ†æ•£

```javascript
// Redis Adapter for Socket.io
const redisAdapter = require('socket.io-redis');
io.adapter(redisAdapter({ host: 'localhost', port: 6379 }));
```

### ç›£è¦–ãƒ»ãƒ­ã‚°

```javascript
// æ¥ç¶šç›£è¦–
io.engine.on('connection_error', (err) => {
  console.log('Connection error:', err.req, err.code, err.message, err.context);
});

// ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
const prometheus = require('prom-client');
const connectionsGauge = new prometheus.Gauge({
  name: 'websocket_connections_total',
  help: 'Total number of WebSocket connections'
});

io.on('connection', (socket) => {
  connectionsGauge.inc();
  socket.on('disconnect', () => {
    connectionsGauge.dec();
  });
});
```

## ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š

### ç’°å¢ƒå¤‰æ•°

```bash
# WebSocketæ¥ç¶šè¨­å®š
WEBSOCKET_URL=ws://your-production-server:port
WEBSOCKET_RECONNECT_ATTEMPTS=10
WEBSOCKET_RECONNECT_DELAY=1000
WEBSOCKET_TIMEOUT=5000

# ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨­å®š
ENABLE_PERFORMANCE_MONITORING=true
ANIMATION_PERFORMANCE_MODE=auto  # high, medium, low, auto
MAX_CONCURRENT_ANIMATIONS=10

# ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«
LOG_LEVEL=info  # debug, info, warn, error
```

### è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«

```json
// config/production.json
{
  "websocket": {
    "url": "wss://your-production-server:443",
    "options": {
      "reconnectionAttempts": 10,
      "reconnectionDelay": 1000,
      "timeout": 5000
    }
  },
  "performance": {
    "enableMonitoring": true,
    "animationMode": "auto",
    "maxConcurrentAnimations": 10
  },
  "ui": {
    "updateInterval": 1000,
    "chartMaxDataPoints": 100,
    "enableAnimations": true
  }
}
```

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### æ¥ç¶šå•é¡Œ

1. **WebSocketæ¥ç¶šå¤±æ•—**
   ```bash
   # ã‚µãƒ¼ãƒãƒ¼çŠ¶æ…‹ç¢ºèª
   curl http://localhost:3001/health
   
   # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç¢ºèª
   telnet localhost 3001
   ```

2. **CORS ã‚¨ãƒ©ãƒ¼**
   - ã‚µãƒ¼ãƒãƒ¼å´ã§CORSè¨­å®šã‚’ç¢ºèª
   - ãƒ–ãƒ©ã‚¦ã‚¶ã®é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã§ã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’ç¢ºèª

3. **èªè¨¼ã‚¨ãƒ©ãƒ¼**
   - JWT ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æ€§ã‚’ç¢ºèª
   - èªè¨¼æƒ…å ±ã®è¨­å®šã‚’ç¢ºèª

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ

1. **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¤šã„**
   - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã§ãƒ¡ãƒˆãƒªã‚¯ã‚¹ç¢ºèª
   - ç”»åƒãƒ‡ãƒ¼ã‚¿ã®ã‚µã‚¤ã‚ºã¨é »åº¦ã‚’èª¿æ•´
   - ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œ

2. **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒé‡ã„**
   - ãƒ‡ãƒã‚¤ã‚¹æ€§èƒ½ã«å¿œã˜ãŸè¨­å®šèª¿æ•´
   - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ•°ã®åˆ¶é™
   - ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ç¢ºèª

### ãƒ‡ãƒ¼ã‚¿å•é¡Œ

1. **ãƒ‡ãƒ¼ã‚¿ãŒæ›´æ–°ã•ã‚Œãªã„**
   - WebSocketæ¥ç¶šçŠ¶æ…‹ã‚’ç¢ºèª
   - ã‚µãƒ¼ãƒãƒ¼å´ã®ãƒ‡ãƒ¼ã‚¿é€ä¿¡ãƒ­ã‚°ã‚’ç¢ºèª
   - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é…å»¶ã®ç¢ºèª

2. **ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚¨ãƒ©ãƒ¼**
   - é€å—ä¿¡ãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ã‚’ç¢ºèª
   - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³çµæœã‚’ç¢ºèª
   - ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®è©³ç´°ç¢ºèª

## è¦ä»¶å¯¾å¿œ

ã“ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯ä»¥ä¸‹ã®è¦ä»¶ã«å¯¾å¿œã—ã¦ã„ã¾ã™ï¼š

### æ©Ÿèƒ½è¦ä»¶
- **è¦ä»¶1.1-1.4**: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çŠ¶æ…‹è¡¨ç¤ºã¨ãƒ©ã‚¤ãƒ–æ˜ åƒ
- **è¦ä»¶2.1-2.2**: é€²æ—å¯è¦–åŒ–ã¨é–¾å€¤æ¯”è¼ƒ
- **è¦ä»¶3.1-3.2**: å±¥æ­´ç®¡ç†ã¨çµ±è¨ˆæƒ…å ±
- **è¦ä»¶4.1-4.2**: ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡ã¨é€šä¿¡å‡¦ç†

### éæ©Ÿèƒ½è¦ä»¶
- **è¦ä»¶5.1**: ãƒ¢ãƒƒã‚¯WebSocketã‚µãƒ¼ãƒãƒ¼ã«ã‚ˆã‚‹ãƒ†ã‚¹ãƒˆç’°å¢ƒ
- **è¦ä»¶5.2**: åŒ…æ‹¬çš„ãªå˜ä½“ãƒ†ã‚¹ãƒˆ
- **è¦ä»¶6.1**: ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³
- **è¦ä»¶6.2**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- **è¦ä»¶6.3**: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
- **è¦ä»¶6.4**: ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ å¯¾å¿œ

## å®Ÿè£…ä¾‹ã¨ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰

### WebSocketã‚µãƒ¼ãƒãƒ¼å®Ÿè£…ä¾‹ï¼ˆå®Œå…¨ç‰ˆï¼‰

```javascript
// server.js - æœ¬æ ¼çš„ãªWebSocketã‚µãƒ¼ãƒãƒ¼å®Ÿè£…ä¾‹
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const jwt = require('jsonwebtoken');

class ManufacturingWebSocketServer {
  constructor(port = 3001) {
    this.port = port;
    this.app = express();
    this.server = http.createServer(this.app);
    this.io = socketIo(this.server, {
      cors: {
        origin: "*",
        methods: ["GET", "POST"]
      }
    });
    
    this.clients = new Map();
    this.sensorData = {
      worker_status: 'waiting',
      robot_status: { state: 'waiting', grip: 'closed' },
      screw_count: 0,
      bolt_count: 0,
      work_step: 'waiting'
    };
    
    this.setupMiddleware();
    this.setupRoutes();
    this.setupWebSocket();
  }
  
  setupMiddleware() {
    this.app.use(cors());
    this.app.use(express.json());
  }
  
  setupRoutes() {
    // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
    this.app.get('/health', (req, res) => {
      res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        connections: this.clients.size
      });
    });
    
    // ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿æ‰‹å‹•æ›´æ–°API
    this.app.post('/sensor-data', (req, res) => {
      this.sensorData = { ...this.sensorData, ...req.body };
      this.broadcastSensorData();
      res.json({ success: true });
    });
    
    // ãƒ­ãƒœãƒƒãƒˆæŒ‡ç¤ºAPI
    this.app.post('/robot-command', (req, res) => {
      this.handleRobotCommand(req.body);
      res.json({ success: true });
    });
  }
  
  setupWebSocket() {
    // èªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    this.io.use((socket, next) => {
      const token = socket.handshake.auth.token;
      if (token) {
        try {
          const decoded = jwt.verify(token, process.env.JWT_SECRET || 'demo-secret');
          socket.userId = decoded.userId;
        } catch (err) {
          return next(new Error('Authentication failed'));
        }
      }
      next();
    });
    
    this.io.on('connection', (socket) => {
      console.log(`Client connected: ${socket.id}`);
      
      // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæƒ…å ±ã‚’ä¿å­˜
      this.clients.set(socket.id, {
        socket,
        connectedAt: new Date(),
        lastPing: new Date()
      });
      
      // åˆæœŸãƒ‡ãƒ¼ã‚¿é€ä¿¡
      socket.emit('sensor_data', this.sensorData);
      
      // å®šæœŸçš„ãªã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿é€ä¿¡
      const dataInterval = setInterval(() => {
        this.updateSensorData();
        socket.emit('sensor_data', this.sensorData);
      }, 1000);
      
      // ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆ
      const heartbeatInterval = setInterval(() => {
        socket.emit('ping', { timestamp: Date.now() });
      }, 30000);
      
      // ãƒ­ãƒœãƒƒãƒˆæŒ‡ç¤ºå—ä¿¡
      socket.on('robot_command', (data) => {
        this.handleRobotCommand(data, socket);
      });
      
      // ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆå¿œç­”
      socket.on('pong', (data) => {
        const client = this.clients.get(socket.id);
        if (client) {
          client.lastPing = new Date();
        }
      });
      
      // åˆ‡æ–­å‡¦ç†
      socket.on('disconnect', (reason) => {
        console.log(`Client disconnected: ${socket.id}, reason: ${reason}`);
        clearInterval(dataInterval);
        clearInterval(heartbeatInterval);
        this.clients.delete(socket.id);
      });
      
      // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
      socket.on('error', (error) => {
        console.error(`Socket error for ${socket.id}:`, error);
      });
    });
  }
  
  updateSensorData() {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã“ã“ã§ã‚»ãƒ³ã‚µãƒ¼ã‚„ã‚«ãƒ¡ãƒ©ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const workerStates = ['waiting', 'screw_tightening', 'bolt_tightening', 'tool_handover'];
    const robotStates = ['waiting', 'operating'];
    const gripStates = ['open', 'closed'];
    
    // ãƒ©ãƒ³ãƒ€ãƒ ãªçŠ¶æ…‹å¤‰æ›´ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯å®Ÿéš›ã®ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼‰
    if (Math.random() > 0.8) {
      this.sensorData.worker_status = workerStates[Math.floor(Math.random() * workerStates.length)];
    }
    
    if (Math.random() > 0.7) {
      this.sensorData.robot_status.state = robotStates[Math.floor(Math.random() * robotStates.length)];
      this.sensorData.robot_status.grip = gripStates[Math.floor(Math.random() * gripStates.length)];
    }
    
    // ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
    if (this.sensorData.worker_status === 'screw_tightening' && Math.random() > 0.9) {
      this.sensorData.screw_count++;
    }
    
    if (this.sensorData.worker_status === 'bolt_tightening' && Math.random() > 0.9) {
      this.sensorData.bolt_count++;
    }
    
    this.sensorData.work_step = this.sensorData.worker_status;
  }
  
  handleRobotCommand(command, socket = null) {
    console.log('Robot command received:', command);
    
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã“ã“ã§ãƒ­ãƒœãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ ã«æŒ‡ç¤ºã‚’é€ä¿¡
    const response = {
      command: command.command,
      status: 'success',
      timestamp: new Date().toISOString(),
      data: command.data
    };
    
    // ã‚³ãƒãƒ³ãƒ‰ã«å¿œã˜ãŸå‡¦ç†
    switch (command.command) {
      case 'tool_handover':
        this.sensorData.robot_status.state = 'operating';
        this.sensorData.robot_status.grip = 'open';
        setTimeout(() => {
          this.sensorData.robot_status.state = 'waiting';
          this.sensorData.robot_status.grip = 'closed';
        }, 3000);
        break;
        
      case 'next_task':
        this.sensorData.worker_status = 'waiting';
        this.sensorData.work_step = 'waiting';
        break;
        
      case 'emergency_stop':
        this.sensorData.robot_status.state = 'waiting';
        this.sensorData.worker_status = 'waiting';
        response.status = 'emergency_stopped';
        break;
    }
    
    // å¿œç­”é€ä¿¡
    if (socket) {
      socket.emit('robot_response', response);
    } else {
      this.io.emit('robot_response', response);
    }
    
    // çŠ¶æ…‹å¤‰æ›´ã‚’ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ
    this.broadcastSensorData();
  }
  
  broadcastSensorData() {
    this.io.emit('sensor_data', this.sensorData);
  }
  
  start() {
    this.server.listen(this.port, () => {
      console.log(`Manufacturing WebSocket Server running on port ${this.port}`);
      console.log(`Health check: http://localhost:${this.port}/health`);
      console.log(`WebSocket: ws://localhost:${this.port}`);
    });
  }
  
  stop() {
    this.server.close();
  }
}

// ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
if (require.main === module) {
  const server = new ManufacturingWebSocketServer(process.env.PORT || 3001);
  server.start();
  
  // å„ªé›…ãªçµ‚äº†å‡¦ç†
  process.on('SIGTERM', () => {
    console.log('SIGTERM received, shutting down gracefully');
    server.stop();
    process.exit(0);
  });
  
  process.on('SIGINT', () => {
    console.log('SIGINT received, shutting down gracefully');
    server.stop();
    process.exit(0);
  });
}

module.exports = ManufacturingWebSocketServer;
```

### ã‚»ãƒ³ã‚µãƒ¼çµ±åˆä¾‹ï¼ˆPythonï¼‰

```python
# sensor_integration.py - ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿çµ±åˆä¾‹
import cv2
import json
import base64
import asyncio
import websockets
from datetime import datetime
import numpy as np

class SensorIntegration:
    def __init__(self, websocket_url="ws://localhost:3001"):
        self.websocket_url = websocket_url
        self.camera = cv2.VideoCapture(0)
        self.running = False
        
    async def connect_and_stream(self):
        """WebSocketã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã¦ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡"""
        try:
            async with websockets.connect(self.websocket_url) as websocket:
                print(f"Connected to {self.websocket_url}")
                self.running = True
                
                while self.running:
                    # ã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿åé›†
                    sensor_data = await self.collect_sensor_data()
                    
                    # WebSocketã§é€ä¿¡
                    await websocket.send(json.dumps({
                        "type": "sensor_data",
                        "data": sensor_data
                    }))
                    
                    # 1ç§’å¾…æ©Ÿ
                    await asyncio.sleep(1)
                    
        except Exception as e:
            print(f"Connection error: {e}")
            
    async def collect_sensor_data(self):
        """å„ç¨®ã‚»ãƒ³ã‚µãƒ¼ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’åé›†"""
        data = {
            "timestamp": datetime.now().isoformat(),
            "worker_status": await self.detect_worker_status(),
            "robot_status": await self.get_robot_status(),
            "screw_count": await self.count_screws(),
            "bolt_count": await self.count_bolts(),
            "image": await self.capture_image()
        }
        return data
        
    async def detect_worker_status(self):
        """ä½œæ¥­è€…çŠ¶æ…‹æ¤œå‡ºï¼ˆAI/ç”»åƒèªè­˜ï¼‰"""
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€AI/MLãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
        ret, frame = self.camera.read()
        if not ret:
            return "absent"
            
        # ç°¡å˜ãªå‹•ãæ¤œå‡ºä¾‹
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€å§¿å‹¢æ¨å®šã‚„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³èªè­˜ã‚’ä½¿ç”¨
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        # ... ç”»åƒå‡¦ç†ãƒ­ã‚¸ãƒƒã‚¯ ...
        
        return "waiting"  # ä»®ã®æˆ»ã‚Šå€¤
        
    async def get_robot_status(self):
        """ãƒ­ãƒœãƒƒãƒˆçŠ¶æ…‹å–å¾—"""
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒ­ãƒœãƒƒãƒˆAPIã‹ã‚‰çŠ¶æ…‹ã‚’å–å¾—
        return {
            "state": "waiting",
            "grip": "closed",
            "position": {"x": 0, "y": 0, "z": 0},
            "battery": 85
        }
        
    async def count_screws(self):
        """ãƒã‚¸ç· ã‚å›æ•°ã‚«ã‚¦ãƒ³ãƒˆ"""
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€æŒ¯å‹•ã‚»ãƒ³ã‚µãƒ¼ã‚„éŸ³éŸ¿ã‚»ãƒ³ã‚µãƒ¼ã‚’ä½¿ç”¨
        return 0
        
    async def count_bolts(self):
        """ãƒœãƒ«ãƒˆç· ã‚å›æ•°ã‚«ã‚¦ãƒ³ãƒˆ"""
        # å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒˆãƒ«ã‚¯ã‚»ãƒ³ã‚µãƒ¼ã‚„ãƒ“ã‚¸ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½¿ç”¨
        return 0
        
    async def capture_image(self):
        """ã‚«ãƒ¡ãƒ©ç”»åƒå–å¾—"""
        ret, frame = self.camera.read()
        if not ret:
            return None
            
        # ç”»åƒã‚’åœ§ç¸®ã—ã¦Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
        _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 80])
        image_base64 = base64.b64encode(buffer).decode('utf-8')
        return f"data:image/jpeg;base64,{image_base64}"
        
    def stop(self):
        """ã‚»ãƒ³ã‚µãƒ¼çµ±åˆåœæ­¢"""
        self.running = False
        if self.camera:
            self.camera.release()

# ä½¿ç”¨ä¾‹
if __name__ == "__main__":
    sensor = SensorIntegration()
    try:
        asyncio.run(sensor.connect_and_stream())
    except KeyboardInterrupt:
        print("Stopping sensor integration...")
        sensor.stop()
```

### ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡çµ±åˆä¾‹ï¼ˆC++ï¼‰

```cpp
// robot_controller.cpp - ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡çµ±åˆä¾‹
#include <iostream>
#include <string>
#include <json/json.h>
#include <websocketpp/config/asio_no_tls.hpp>
#include <websocketpp/client.hpp>

class RobotController {
private:
    websocketpp::client<websocketpp::config::asio> client;
    websocketpp::connection_hdl connection;
    bool connected = false;
    
public:
    RobotController() {
        // WebSocketã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­å®š
        client.set_access_channels(websocketpp::log::alevel::all);
        client.clear_access_channels(websocketpp::log::alevel::frame_payload);
        client.init_asio();
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š
        client.set_message_handler([this](websocketpp::connection_hdl hdl, websocketpp::client<websocketpp::config::asio>::message_ptr msg) {
            this->on_message(hdl, msg);
        });
        
        client.set_open_handler([this](websocketpp::connection_hdl hdl) {
            this->on_open(hdl);
        });
        
        client.set_close_handler([this](websocketpp::connection_hdl hdl) {
            this->on_close(hdl);
        });
    }
    
    void connect(const std::string& uri) {
        websocketpp::lib::error_code ec;
        auto con = client.get_connection(uri, ec);
        
        if (ec) {
            std::cout << "Connection error: " << ec.message() << std::endl;
            return;
        }
        
        connection = con->get_handle();
        client.connect(con);
        client.run();
    }
    
    void on_open(websocketpp::connection_hdl hdl) {
        std::cout << "Connected to WebSocket server" << std::endl;
        connected = true;
        
        // åˆæœŸçŠ¶æ…‹é€ä¿¡
        send_robot_status();
    }
    
    void on_close(websocketpp::connection_hdl hdl) {
        std::cout << "Disconnected from WebSocket server" << std::endl;
        connected = false;
    }
    
    void on_message(websocketpp::connection_hdl hdl, websocketpp::client<websocketpp::config::asio>::message_ptr msg) {
        Json::Value root;
        Json::Reader reader;
        
        if (reader.parse(msg->get_payload(), root)) {
            std::string type = root.get("type", "").asString();
            
            if (type == "robot_command") {
                handle_command(root["data"]);
            }
        }
    }
    
    void handle_command(const Json::Value& command) {
        std::string cmd = command.get("command", "").asString();
        std::cout << "Received command: " << cmd << std::endl;
        
        if (cmd == "tool_handover") {
            execute_tool_handover(command["data"]);
        } else if (cmd == "next_task") {
            move_to_next_task();
        } else if (cmd == "emergency_stop") {
            emergency_stop();
        }
        
        // å¿œç­”é€ä¿¡
        send_command_response(cmd, "success");
    }
    
    void execute_tool_handover(const Json::Value& data) {
        std::cout << "Executing tool handover..." << std::endl;
        
        // å®Ÿéš›ã®ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡ã‚³ãƒ¼ãƒ‰
        // move_to_position(data["position"]);
        // open_gripper();
        // wait_for_handover();
        // close_gripper();
        
        std::cout << "Tool handover completed" << std::endl;
    }
    
    void move_to_next_task() {
        std::cout << "Moving to next task..." << std::endl;
        // å®Ÿéš›ã®ãƒ­ãƒœãƒƒãƒˆåˆ¶å¾¡ã‚³ãƒ¼ãƒ‰
    }
    
    void emergency_stop() {
        std::cout << "Emergency stop activated!" << std::endl;
        // å®Ÿéš›ã®ç·Šæ€¥åœæ­¢ã‚³ãƒ¼ãƒ‰
    }
    
    void send_robot_status() {
        if (!connected) return;
        
        Json::Value status;
        status["type"] = "robot_status";
        status["data"]["state"] = "waiting";
        status["data"]["grip"] = "closed";
        status["data"]["position"]["x"] = 0;
        status["data"]["position"]["y"] = 0;
        status["data"]["position"]["z"] = 0;
        status["data"]["battery"] = 85;
        status["timestamp"] = get_current_timestamp();
        
        Json::StreamWriterBuilder builder;
        std::string message = Json::writeString(builder, status);
        
        client.send(connection, message, websocketpp::frame::opcode::text);
    }
    
    void send_command_response(const std::string& command, const std::string& status) {
        if (!connected) return;
        
        Json::Value response;
        response["type"] = "robot_response";
        response["data"]["command"] = command;
        response["data"]["status"] = status;
        response["timestamp"] = get_current_timestamp();
        
        Json::StreamWriterBuilder builder;
        std::string message = Json::writeString(builder, response);
        
        client.send(connection, message, websocketpp::frame::opcode::text);
    }
    
    std::string get_current_timestamp() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss << std::put_time(std::gmtime(&time_t), "%Y-%m-%dT%H:%M:%SZ");
        return ss.str();
    }
};

// ä½¿ç”¨ä¾‹
int main() {
    RobotController controller;
    controller.connect("ws://localhost:3001");
    return 0;
}
```

## ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆã‚¬ã‚¤ãƒ‰

### DockeråŒ–

```dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

# ä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
COPY package*.json ./
RUN npm ci --only=production

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ”ãƒ¼
COPY dist/ ./dist/
COPY config/ ./config/

# ãƒãƒ¼ãƒˆå…¬é–‹
EXPOSE 3001

# ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3001/health || exit 1

# èµ·å‹•
CMD ["npm", "start"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  manufacturing-app:
    build: .
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=production
      - JWT_SECRET=${JWT_SECRET}
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    
  redis:
    image: redis:alpine
    ports:
      - "6379:6379"
    restart: unless-stopped
    
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - manufacturing-app
    restart: unless-stopped
```

### Kubernetes ãƒ‡ãƒ—ãƒ­ã‚¤

```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: manufacturing-websocket
spec:
  replicas: 3
  selector:
    matchLabels:
      app: manufacturing-websocket
  template:
    metadata:
      labels:
        app: manufacturing-websocket
    spec:
      containers:
      - name: websocket-server
        image: manufacturing-websocket:latest
        ports:
        - containerPort: 3001
        env:
        - name: NODE_ENV
          value: "production"
        - name: REDIS_URL
          value: "redis://redis-service:6379"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: manufacturing-websocket-service
spec:
  selector:
    app: manufacturing-websocket
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3001
  type: LoadBalancer
```

ã“ã®READMEã«ã‚ˆã‚Šã€WebSocketé€šä¿¡ã¨ãƒ‡ãƒ¼ã‚¿é€£æºã®ä»•çµ„ã¿ã€ã‚µãƒ¼ãƒãƒ¼å´ã®å®Ÿè£…è¦ä»¶ã€ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆæ–¹æ³•ã¾ã§åŒ…æ‹¬çš„ã«ã‚«ãƒãƒ¼ã—ã¦ã„ã¾ã™ã€‚å®Ÿéš›ã®è£½é€ ç¾å ´ã§ã®å°å…¥æ™‚ã«ã¯ã€ã“ã‚Œã‚‰ã®æƒ…å ±ã‚’å‚è€ƒã«ç’°å¢ƒã«å¿œã˜ãŸã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã‚’è¡Œã£ã¦ãã ã•ã„ã€‚